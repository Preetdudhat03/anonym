File: s:\anonym\server.js

Overview:
This file is the main entry point for the custom backend server. It sets up a Next.js app with a custom Node.js server to handle WebSocket connections (for real-time chat) alongside standard HTTP requests. It uses Redis for rate limiting (setup only), Supabase for database persistence, and TweetNaCl for cryptographic verification.

Detailed Line-by-Line Explanation:

1: const { createServer } = require('http');
Reason: Import the native Node.js HTTP module to create a raw HTTP server. We need this to attach both Next.js and a WebSocket server to the same port.

2: const { parse } = require('url');
Reason: Import the URL parser to break down incoming request URLs (e.g., separating pathname from query strings), which Next.js needs to handle routing.

3: const next = require('next');
Reason: Import the Next.js framework. We are using it programmatically ("Custom Server" mode) so we can control the request lifecycle and add WebSockets.

4: const { WebSocketServer } = require('ws');
Reason: Import the 'ws' library to create a WebSocket server. This is essential for the real-time, bi-directional communication required for the chat.

5: const { v4: uuidv4 } = require('uuid');
Reason: Import the UUID generator (version 4). We use this to assign unique IDs to every WebSocket connection and nonce for auth challenges.

6: const { createClient } = require('@supabase/supabase-js');
Reason: Import the Supabase client library. This allows the server to interact with the Postgres database (e.g., storing messages, checking users) using a convenient API.

7: const Redis = require('ioredis');
Reason: Import the Redis client. Redis is an in-memory data store used here typically for rate limiting or fast session caching, mostly for performance and security.

8: const crypto = require('crypto');
Reason: Import Node.js built-in crypto library. Used here for hashing (SHA-256) to verify address integrity.

9: const nacl = require('tweetnacl');
Reason: Import TweetNaCl, a low-level crypto library. We use this specifically for verifying Ed25519 digital signatures during the authentication handshake.

10: const { decodeBase64 } = require('tweetnacl-util');
Reason: Import a utility to decode Base64 strings into Uint8Arrays, which TweetNaCl needs for its operations.

12: const dev = process.env.NODE_ENV !== 'production';
Reason: Determine if we are in development mode based on environment variables. Next.js behaves differently (hot reloading, error reporting) in dev vs production.

13: const app = next({ dev });
Reason: Initialize the Next.js application instance.

14: const handle = app.getRequestHandler();
Reason: Get the Next.js request handler function. This function knows how to serve pages, API routes, and static files generated by Next.js.

16: // Redis (Rate Limiting Support)
17: const redis = new Redis({
18:     lazyConnect: true,
19:     retryStrategy: (times) => Math.min(times * 50, 2000)
20: });
Reason: Initialize the Redis client with connection options. 'lazyConnect' means it won't crash immediately if Redis is down (good for local dev). 'retryStrategy' defines how to back off if connection is lost.

21: redis.on('error', (err) => console.log('Redis Error (Ignorable if local):', err.message));
Reason: Add an error listener to prevent the server from crashing if Redis isn't running (common in simple local setups).

23: // In-Memory Socket Map (Address -> WS)
24: const clients = new Map();
Reason: create a Map to store active WebSocket connections. The key will be the user's Wallet/Identity Address, and the value is the WebSocket object. This allows us to route messages to specific users efficiently.

26: // Helper: Verify Ed25519 Signature
27: function verifySignature(publicKeyBase64, nonceStr, signatureBase64) {
Reason: Define a helper function to verify that a client actually owns the private key they claim to have.

28:     try {
29:         const pubKey = decodeBase64(publicKeyBase64);
Reason: Decode the public key from Base64 to raw bytes.

30:         const sig = decodeBase64(signatureBase64);
Reason: Decode the signature from Base64 to raw bytes.

31:         const msg = new TextEncoder().encode(nonceStr);
Reason: Convert the nonce string (the challenge message) into raw bytes.

32:         return nacl.sign.detached.verify(msg, sig, pubKey);
Reason: Use TweetNaCl to cryptographically verify if 'sig' was created by the private key corresponding to 'pubKey' for the message 'msg'. Returns true/false.

33:     } catch (e) {
34:         console.error("Sig Verify Error", e.message);
35:         return false;
Reason: safely handle any decoding or crypto errors by returning false (auth failed) instead of crashing.

39: app.prepare().then(() => {
Reason: Start the Next.js app preparation. We wait for this promise to resolve before starting our server handling commands.

40:     const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
41:     const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY;
42:     const supabase = createClient(supabaseUrl, supabaseKey);
Reason: Initialize the Supabase client inside the server closure using environment variables for configuration.

44:     const server = createServer((req, res) => {
45:         const parsedUrl = parse(req.url, true);
46:         handle(req, res, parsedUrl);
47:     });
Reason: Create the generic Node.js HTTP server. For every normal HTTP request, we just pass it to 'handle', letting Next.js deal with it (serving pages, APIs).

49:     const wss = new WebSocketServer({ noServer: true });
Reason: Initialize the WebSocket Server instance, but with 'noServer: true'. This means it won't listen on a port by itself; we will manually "upgrade" HTTP requests to WebSocket connections.

51:     server.on('upgrade', (request, socket, head) => {
Reason: Listen for the 'upgrade' event on the HTTP server. This event fires when a client tries to open a WebSocket connection.

52:         if (request.url.startsWith('/api/ws')) {
Reason: Check if the request URL matches our designated WebSocket endpoint ('/api/ws'). We only want to accept WebSockets there.

53:             wss.handleUpgrade(request, socket, head, (ws) => {
54:                 wss.emit('connection', ws, request);
55:             });
Reason: If URL matches, formally upgrade the connection from HTTP to WebSocket and emit the 'connection' event for our logic to handle.

59:     wss.on('connection', (ws) => {
Reason: Main event handler for a new WebSocket connection. 'ws' is the connection object for that specific client.

60:         ws.id = uuidv4();
Reason: Assign a temporary unique ID for logging/debugging purposes.

61:         ws.isAuthed = false;
Reason: Mark the connection as unauthenticated by default. They must prove their identity before we let them send messages.

64:         const authTimeout = setTimeout(() => {
65:             if (!ws.isAuthed) ws.close(4001, "Auth Timeout");
66:         }, 10000);
Reason: set a 10-second timer. If the user doesn't complete the cryptic handshake by then, boot them. Prevents stuck/spam connections.

68:         ws.on('message', async (message) => {
Reason: Event listener for when the server receives a message from this client.

70:                 const data = JSON.parse(message);
Reason: Parse the incoming message string as JSON.

74:                 if (data.type === 'auth_request') {
Reason: Handle Step 1 of Auth: Client asks to log in.

75:                     const { identityPublicKey, encryptionPublicKey } = data; // Base64 strings
Reason: Extract the keys the client claims to own.

76:                     if (!identityPublicKey || !encryptionPublicKey) return ws.close(4002, "Missing Keys");
Reason: Validation check.

78:                     const nonce = uuidv4();
Reason: Generate a random 'challenge' string (nonce) that the client must sign.

79:                     ws.authPending = { identityPublicKey, encryptionPublicKey, nonce };
Reason: Store the pending auth state on the socket object for the next step.

80:                     ws.send(JSON.stringify({ type: 'auth_challenge', nonce }));
Reason: Send the challenge back to the client.

86:                 if (data.type === 'auth_response') {
Reason: Handle Step 2 of Auth: Client responds with the signature.

87:                     if (!ws.authPending) return ws.close(4003, "No Pending Auth");
Reason: Security check: Can't answer a challenge if you didn't ask for one.

89:                     const { signature } = data;
90:                     if (!verifySignature(ws.authPending.identityPublicKey, ws.authPending.nonce, signature)) {
91:                         return ws.close(4004, "Invalid Signature");
92:                     }
Reason: Verify the signature. If bad, disconnect immediately.

95:                     clearTimeout(authTimeout);
96:                     ws.isAuthed = true;
Reason: Auth successful. Cancel the kickoff timer and mark as authed.

101:                     const rawPub = decodeBase64(ws.authPending.identityPublicKey);
102:                     const hash = crypto.createHash('sha256').update(rawPub).digest('hex');
103:                     ws.address = hash;
Reason: Calculate the "Address" of the user. We hash their public key to get a deterministic ID. This matches how the client does it.

106:                     clients.set(hash, ws);
Reason: Add the authenticated client to our active map, so other users can message them by this Address.

109:                     const { generateShortCode } = require('./shortcode');
Reason: Import the shortcode generator logic.

110:                     let shortCode = generateShortCode(hash, 0);
Reason: Generate a readable shortcode (like A1B2-C3D4) from their hash.

121:                     const { data: existingUser } = await supabase.from('users').select('short_code').eq('public_key_hash', hash).single();
Reason: Check the database to see if this user already exists.

123:                     if (existingUser) {
124:                         shortCode = existingUser.short_code;
Reason: If they exist, reuse their old shortcode so it doesn't change.

127:                         while (!inserted && attempts < 5) {
Reason: If new user, loop to insert code. If there's a collision (someone else has that code), we retry.

129:                             if (attempts > 0) shortCode = generateShortCode(hash, attempts);
Reason: If retrying, generate a new variation of the code using a 'nonce' (attempts count).

131:                             const { error } = await supabase.from('users').insert({ ... });
Reason: Attempt to save the new user to the database.

156:                     ws.send(JSON.stringify({
157:                         type: 'auth_success',
158:                         address: hash,
159:                         shortCode: shortCode
160:                     }));
Reason: Tell the client they are logged in successfully and give them their details.

166:                 if (data.type === 'request_history') {
Reason: Handle request to sync old messages.

171:                     const { data: history, error } = await supabase.from('messages')...
Reason: Query database for last 50 messages where this user was sender OR receiver.

180:                         history.reverse().forEach(msg => {
Reason: Loop through history and send messages one by one to the client.

205:                 if (data.type === 'message') {
Reason: Handle sending a new message.

211:                     // A. Enforce Expiration Cap (Max 24h)
Reason: Calculate when this message should auto-delete. We cap it at 24 hours max for privacy.

224:                     const packedMeta = JSON.stringify({ ... });
Reason: Pack technical decryption data (Ephemeral Key + IV) into a JSON string to store in one DB column.

229:                     await supabase.from('messages').insert({ ... });
Reason: Save the encrypted message to the database (Store-and-Forward architecture).

238:                     const recipient = clients.get(targetAddress);
239:                     if (recipient && recipient.readyState === 1) {
Reason: Check if the recipient is currently online and connected to this server instance.

241:                         setTimeout(() => {
Reason: Add a tiny random delay before forwarding. This defeats "traffic analysis" attacks where an observer matches incoming packet times to outgoing ones.

242:                             recipient.send(JSON.stringify({ ... }));
Reason: Forward the message to the recipient instantly via WebSocket.

264:         ws.on('close', () => {
265:             if (ws.address) clients.delete(ws.address);
266:         });
Reason: Cleanup: When connection closes, remove them from the active clients map.

269:     server.listen(3000, (err) => {
Reason: Start listening on port 3000.

274:         setInterval(async () => {
275:             const { error } = await supabase.from('messages').delete().lt('expires_at', new Date().toISOString());
276:             if (error) console.error("TTL Error", error);
277:         }, 60000);
Reason: Setup a background task that runs every minute to wipe old messages from the database (TTL - Time To Live) to enforce privacy.
